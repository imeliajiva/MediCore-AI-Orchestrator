import { GoogleGenAI, Type, Schema } from "@google/genai";
import { AgentType, AgentResponse } from '../types';

const apiKey = process.env.API_KEY || '';
const ai = new GoogleGenAI({ apiKey });

// Schema definition for the structured output
const responseSchema: Schema = {
  type: Type.OBJECT,
  properties: {
    agentType: {
      type: Type.STRING,
      enum: [AgentType.RME, AgentType.ADMIN, AgentType.CLINICAL, AgentType.EDUCATION],
      description: "The specific sub-agent selected to handle the request."
    },
    reasoning: {
      type: Type.STRING,
      description: "Brief explanation of why this agent was selected by the Coordinator."
    },
    content: {
      type: Type.STRING,
      description: "The textual response generated by the selected sub-agent."
    },
    // We use a flexible stringified JSON approach for specific data to keep the schema simple yet powerful
    // or we can define a generic object structure. Here we allow the model to return relevant structured info.
    structuredDataContext: {
      type: Type.STRING,
      description: "A valid JSON string containing specific data (e.g., aging schedule array, vitals list, education bullet points) tailored to the agent type."
    }
  },
  required: ["agentType", "reasoning", "content"]
};

const SYSTEM_INSTRUCTION = `
You are the "Master Agent" (Coordinator) for a modern Hospital Information System.
Your goal is to analyze user input and route it to one of four specialized Sub-Agents.
You must act as the selected Sub-Agent to generate the final response.

THE SUB-AGENTS:

1. RME (Rekam Medis Elektronik / EMR):
   - Focus: Patient data integrity, ICD-10 coding, transcription, compliance (Permenkes No 24 Tahun 2022).
   - Tone: Formal, precise, clinical documentation style.
   - Task: Convert informal notes to structured medical records, ensure data completeness.

2. ADMIN (Accounting & Administrative):
   - Focus: Billing, Insurance (BPJS), Claims, Accounts Receivable (Aging Schedule).
   - Tone: Professional, financial, analytical.
   - Task: Analyze financial health, categorize debts, explain billing discrepancies.

3. CLINICAL (Clinical Decision Support):
   - Focus: Diagnosis assistance, analyzing symptoms, lab results, DICOM/Imaging context.
   - Tone: Objective, scientific, supportive (but always clarify it is AI advice, not a doctor).
   - Task: Suggest differential diagnoses, highlight critical values, interpret imaging descriptions.

4. EDUCATION (Patient Education):
   - Focus: Explaining complex medical terms to laypeople, post-op care, wellness.
   - Tone: Empathetic, simple, clear, encouraging (avoid jargon).
   - Task: Create brochures, simplify diagnoses, explain medication instructions.

INSTRUCTIONS:
1. Analyze the input.
2. Select the BEST agent.
3. Generate the response content based on that agent's persona.
4. Provide structured data in 'structuredDataContext' as a JSON string:
   - For ADMIN: Provide 'agingSchedule' (array of {period: '0-30 days', amount: number, riskLevel: string}).
   - For RME: Provide 'extractedFields' (object with patientName, diagnosis, icdCode, plan).
   - For CLINICAL: Provide 'riskAssessment' (array of {metric: string, value: string, status: string}).
   - For EDUCATION: Provide 'keyPoints' (array of {topic: string, explanation: string, icon: string}).

If the input is general or unclear, default to ADMIN or ask for clarification within the Coordinator reasoning, but try to infer the best fit.
`;

export const processHospitalRequest = async (prompt: string): Promise<AgentResponse> => {
  if (!apiKey) {
    // Mock response for when API key is missing (development safety)
    return {
      agentType: AgentType.COORDINATOR,
      reasoning: "API Key missing. Simulating response.",
      content: "Please configure your Google Gemini API Key to enable the AI agents.",
      timestamp: new Date().toISOString()
    };
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        systemInstruction: SYSTEM_INSTRUCTION,
        responseMimeType: "application/json",
        responseSchema: responseSchema,
        temperature: 0.4, // Keep it relatively deterministic for system logic
      }
    });

    const jsonText = response.text;
    if (!jsonText) throw new Error("Empty response from AI");

    const parsed = JSON.parse(jsonText);
    
    let structuredData = null;
    try {
        if(parsed.structuredDataContext) {
            structuredData = JSON.parse(parsed.structuredDataContext);
        }
    } catch (e) {
        console.warn("Failed to parse structured data context", e);
    }

    return {
      agentType: parsed.agentType as AgentType,
      reasoning: parsed.reasoning,
      content: parsed.content,
      structuredData: structuredData,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    console.error("AI Service Error:", error);
    return {
      agentType: AgentType.COORDINATOR,
      reasoning: "System Error encountered during processing.",
      content: "I apologize, but I am unable to process your request at this moment. Please verify the system connection.",
      timestamp: new Date().toISOString()
    };
  }
};
